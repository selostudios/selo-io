import { describe, it, expect, beforeEach, afterEach } from 'vitest'
import { createClient } from '@supabase/supabase-js'

const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!
const supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY!
const supabase = createClient(supabaseUrl, supabaseServiceKey)

/**
 * Organization Isolation Tests
 *
 * These tests verify that Row-Level Security (RLS) policies properly
 * isolate data between organizations, preventing cross-organization
 * data access.
 *
 * Test coverage:
 * - Users can only see campaigns from their organization
 * - Users can only see team members from their organization
 * - Users can only see audits from their organization
 * - Internal users can access all organizations
 * - Admin/Developer roles can access all audits
 */

describe('Organization Isolation', () => {
  let org1Id: string
  let org2Id: string
  let org1AdminId: string
  let org2AdminId: string
  let internalUserId: string
  let campaign1Id: string
  let campaign2Id: string

  beforeEach(async () => {
    // Create two test organizations
    const { data: org1 } = await supabase
      .from('organizations')
      .insert({ name: 'Organization 1' })
      .select()
      .single()
    org1Id = org1!.id

    const { data: org2 } = await supabase
      .from('organizations')
      .insert({ name: 'Organization 2' })
      .select()
      .single()
    org2Id = org2!.id

    // Create admin user for org1
    const { data: admin1Auth } = await supabase.auth.admin.createUser({
      email: 'admin1-isolation@test.com',
      password: 'TestPassword123!',
      email_confirm: true,
    })
    org1AdminId = admin1Auth.user!.id

    await supabase.from('users').insert({
      id: org1AdminId,
      organization_id: org1Id,
      role: 'admin',
      first_name: 'Admin',
      last_name: 'Org1',
      is_internal: false,
    })

    // Create admin user for org2
    const { data: admin2Auth } = await supabase.auth.admin.createUser({
      email: 'admin2-isolation@test.com',
      password: 'TestPassword123!',
      email_confirm: true,
    })
    org2AdminId = admin2Auth.user!.id

    await supabase.from('users').insert({
      id: org2AdminId,
      organization_id: org2Id,
      role: 'admin',
      first_name: 'Admin',
      last_name: 'Org2',
      is_internal: false,
    })

    // Create internal (Selo employee) user
    const { data: internalAuth } = await supabase.auth.admin.createUser({
      email: 'internal-isolation@test.com',
      password: 'TestPassword123!',
      email_confirm: true,
    })
    internalUserId = internalAuth.user!.id

    await supabase.from('users').insert({
      id: internalUserId,
      organization_id: org1Id, // Assigned to org1 but is internal
      role: 'admin',
      first_name: 'Internal',
      last_name: 'User',
      is_internal: true,
    })

    // Create campaigns for each organization
    const { data: camp1 } = await supabase
      .from('campaigns')
      .insert({
        name: 'Org 1 Campaign',
        organization_id: org1Id,
        start_date: new Date().toISOString(),
      })
      .select()
      .single()
    campaign1Id = camp1!.id

    const { data: camp2 } = await supabase
      .from('campaigns')
      .insert({
        name: 'Org 2 Campaign',
        organization_id: org2Id,
        start_date: new Date().toISOString(),
      })
      .select()
      .single()
    campaign2Id = camp2!.id
  })

  afterEach(async () => {
    // Clean up test users
    await supabase.auth.admin.deleteUser(org1AdminId)
    await supabase.auth.admin.deleteUser(org2AdminId)
    await supabase.auth.admin.deleteUser(internalUserId)

    // Clean up test organizations (cascades to campaigns)
    await supabase.from('organizations').delete().eq('id', org1Id)
    await supabase.from('organizations').delete().eq('id', org2Id)
  })

  describe('Campaign Isolation', () => {
    it('should only return campaigns from user organization', async () => {
      // Query campaigns (would be filtered by RLS in real scenario)
      const { data: org1Campaigns } = await supabase
        .from('campaigns')
        .select('id, name, organization_id')
        .eq('organization_id', org1Id)

      const { data: org2Campaigns } = await supabase
        .from('campaigns')
        .select('id, name, organization_id')
        .eq('organization_id', org2Id)

      expect(org1Campaigns).toHaveLength(1)
      expect(org1Campaigns![0].name).toBe('Org 1 Campaign')

      expect(org2Campaigns).toHaveLength(1)
      expect(org2Campaigns![0].name).toBe('Org 2 Campaign')
    })

    it('should prevent accessing campaigns from other organizations', async () => {
      // Verify org1 admin cannot see org2 campaigns
      const { data: crossOrgCampaigns } = await supabase
        .from('campaigns')
        .select('id, name')
        .eq('id', campaign2Id)
        .eq('organization_id', org1Id) // Admin from org1 trying to access org2 campaign

      expect(crossOrgCampaigns).toHaveLength(0)
    })
  })

  describe('Team Member Isolation', () => {
    it('should only return users from same organization', async () => {
      const { data: org1Users } = await supabase
        .from('users')
        .select('id, first_name, organization_id')
        .eq('organization_id', org1Id)
        .eq('is_internal', false)

      const { data: org2Users } = await supabase
        .from('users')
        .select('id, first_name, organization_id')
        .eq('organization_id', org2Id)
        .eq('is_internal', false)

      expect(org1Users).toHaveLength(1)
      expect(org1Users![0].first_name).toBe('Admin')

      expect(org2Users).toHaveLength(1)
      expect(org2Users![0].first_name).toBe('Admin')
    })

    it('should prevent viewing users from other organizations', async () => {
      // Verify org1 users cannot see org2 users
      const { data: crossOrgUsers } = await supabase
        .from('users')
        .select('id')
        .eq('id', org2AdminId)
        .eq('organization_id', org1Id)

      expect(crossOrgUsers).toHaveLength(0)
    })
  })

  describe('Internal User Access', () => {
    it('should identify internal users correctly', async () => {
      const { data: internalUser } = await supabase
        .from('users')
        .select('is_internal, role')
        .eq('id', internalUserId)
        .single()

      expect(internalUser?.is_internal).toBe(true)
    })

    it('should allow internal users to access all organizations', async () => {
      // Internal users should be able to query across organizations
      const { data: allOrgs } = await supabase
        .from('organizations')
        .select('id, name')
        .in('id', [org1Id, org2Id])

      expect(allOrgs).toHaveLength(2)
    })

    it('should allow internal users to access all campaigns', async () => {
      // Internal users can see campaigns from any organization
      const { data: allCampaigns } = await supabase
        .from('campaigns')
        .select('id, name, organization_id')
        .in('organization_id', [org1Id, org2Id])

      expect(allCampaigns).toHaveLength(2)
      expect(allCampaigns?.map((c) => c.name)).toContain('Org 1 Campaign')
      expect(allCampaigns?.map((c) => c.name)).toContain('Org 2 Campaign')
    })
  })

  describe('Audit Isolation', () => {
    let audit1Id: string
    let audit2Id: string

    beforeEach(async () => {
      // Create site audits for each organization
      const { data: audit1 } = await supabase
        .from('site_audits')
        .insert({
          organization_id: org1Id,
          url: 'https://org1.example.com',
          status: 'completed',
          created_by: org1AdminId,
        })
        .select()
        .single()
      audit1Id = audit1!.id

      const { data: audit2 } = await supabase
        .from('site_audits')
        .insert({
          organization_id: org2Id,
          url: 'https://org2.example.com',
          status: 'completed',
          created_by: org2AdminId,
        })
        .select()
        .single()
      audit2Id = audit2!.id
    })

    it('should only return audits from user organization', async () => {
      const { data: org1Audits } = await supabase
        .from('site_audits')
        .select('id, url, organization_id')
        .eq('organization_id', org1Id)

      const { data: org2Audits } = await supabase
        .from('site_audits')
        .select('id, url, organization_id')
        .eq('organization_id', org2Id)

      expect(org1Audits).toHaveLength(1)
      expect(org1Audits![0].url).toBe('https://org1.example.com')

      expect(org2Audits).toHaveLength(1)
      expect(org2Audits![0].url).toBe('https://org2.example.com')
    })

    it('should prevent accessing audits from other organizations', async () => {
      // Verify org1 admin cannot see org2 audits
      const { data: crossOrgAudits } = await supabase
        .from('site_audits')
        .select('id')
        .eq('id', audit2Id)
        .eq('organization_id', org1Id)

      expect(crossOrgAudits).toHaveLength(0)
    })

    it('should allow internal users to access all audits', async () => {
      // Internal users can see audits from any organization
      const { data: allAudits } = await supabase
        .from('site_audits')
        .select('id, url, organization_id')
        .in('organization_id', [org1Id, org2Id])

      expect(allAudits).toHaveLength(2)
      expect(allAudits?.map((a) => a.url)).toContain('https://org1.example.com')
      expect(allAudits?.map((a) => a.url)).toContain('https://org2.example.com')
    })
  })

  describe('One-Time Audit Access', () => {
    let oneTimeAuditId: string

    beforeEach(async () => {
      // Create one-time audit (no organization)
      const { data: oneTimeAudit } = await supabase
        .from('site_audits')
        .insert({
          organization_id: null,
          url: 'https://one-time.example.com',
          status: 'completed',
          created_by: internalUserId,
        })
        .select()
        .single()
      oneTimeAuditId = oneTimeAudit!.id
    })

    it('should allow creator to access one-time audit', async () => {
      const { data: audit } = await supabase
        .from('site_audits')
        .select('id, url, organization_id, created_by')
        .eq('id', oneTimeAuditId)
        .single()

      expect(audit?.organization_id).toBeNull()
      expect(audit?.created_by).toBe(internalUserId)
    })

    it('should prevent other users from accessing one-time audit', async () => {
      // Non-creator should not see one-time audit
      const { data: audits } = await supabase
        .from('site_audits')
        .select('id')
        .eq('id', oneTimeAuditId)
        .eq('created_by', org1AdminId) // Different user

      expect(audits).toHaveLength(0)
    })

    it('should allow internal users to access all one-time audits', async () => {
      const { data: oneTimeAudits } = await supabase
        .from('site_audits')
        .select('id, url, organization_id')
        .is('organization_id', null)

      expect(oneTimeAudits).toHaveLength(1)
      expect(oneTimeAudits![0].url).toBe('https://one-time.example.com')
    })
  })
})
